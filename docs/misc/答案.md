# 回答: 是否可以实现 JSON → FFmpeg 命令的转换?

## ✅ 答案: **完全可以!而且已经实现了!**

---

## 📋 你的需求

> 输入: `worker/test/fixtures/simple-timeline.json`
> 输出: 可以在命令行中直接执行的 FFmpeg 命令行字符串
> 平台: Cloudflare Worker API

---

## 🎯 实现方式 (两种)

### 方式一: 直接使用 Node.js (本地)

**最简单的方式,无需启动 Worker**

```bash
# 安装依赖并构建
npm install
npm run build

# 生成 FFmpeg 命令
node demo-generate-command.js worker/test/fixtures/simple-timeline.json

# 保存到文件
node demo-generate-command.js worker/test/fixtures/simple-timeline.json > output.sh

# 直接执行
bash output.sh
```

**输出示例**:
```bash
#!/bin/bash
mkdir -p ./tmp
ffmpeg -y -i samples/bee1920.mp4 -ss 27 -t 5 -r 30 ./tmp/clip4.mp4
ffmpeg -y -i samples/book1920.mp4 -ss 0 -t 5 -r 30 ./tmp/clip5.mp4
ffmpeg -y \
-i ./tmp/clip4.mp4 \
-i ./tmp/clip5.mp4 \
-filter_complex "color=c=black:s=384x216:d=8[base];
...完整的滤镜链...
[base][track_with_some_videos]overlay=0:0[video_output];
anullsrc=channel_layout=stereo:sample_rate=44100:d=8[audio_output];" \
-map '[video_output]' -map '[audio_output]' -c:v libx264 -c:a aac -b:a 320k -r 30 -s 384x216 -ss 0 -t 8 -crf 23 -preset veryfast -pix_fmt yuv420p output.mp4
```

✅ **这个输出可以直接复制粘贴到命令行执行!**

---

### 方式二: 使用 Cloudflare Worker API

**更灵活,适合 Web 应用和微服务**

#### 1. 启动 Worker

```bash
cd worker
npm install
npm run dev
```

Worker 运行在: `http://localhost:8787`

#### 2. 调用 API

**使用 curl**:
```bash
# 发送 JSON,获取 FFmpeg 命令
curl -X POST http://localhost:8787/build \
  -H "Content-Type: application/json" \
  -d @worker/test/fixtures/simple-timeline.json
```

**API 响应**:
```json
{
  "command": "#!/bin/bash\nmkdir -p ./tmp\nffmpeg -y ...",
  "args": ["-y", "-i", "samples/bee1920.mp4", ...],
  "warnings": []
}
```

#### 3. 提取命令

**使用 jq 提取 command 字段**:
```bash
curl -s -X POST http://localhost:8787/build \
  -H "Content-Type: application/json" \
  -d @worker/test/fixtures/simple-timeline.json \
  | jq -r '.command' > output.sh

# 执行
bash output.sh
```

**或使用提供的脚本**:
```bash
cd worker
./examples/extract-command.sh test/fixtures/simple-timeline.json output.sh
bash output.sh
```

---

## 🧪 测试验证

### 快速测试

```bash
# 方式 1: Node.js 直接生成
npm run build
node demo-generate-command.js worker/test/fixtures/simple-timeline.json

# 方式 2: Worker API 测试
cd worker
npm run dev  # 启动 Worker (另一个终端)
./test-api-complete.sh  # 运行完整测试
```

### 测试已通过 ✅

```bash
$ npm test

 ✓ test/tokenizer.test.ts  (7 tests) 2ms
 ✓ test/build.test.ts  (5 tests) 3ms

 Test Files  2 passed (2)
      Tests  12 passed (12)
```

---

## 📊 API 端点

### POST /build

**功能**: 生成 FFmpeg 命令

**请求**:
```bash
POST http://localhost:8787/build
Content-Type: application/json

{
  "version": 1,
  "inputs": {...},
  "tracks": {...},
  "transitions": [...],
  "output": {...}
}
```

**响应**:
```json
{
  "command": "完整的 shell 脚本字符串 (可直接执行)",
  "args": ["参数数组", "用于编程调用"],
  "warnings": ["可选的警告信息"]
}
```

### GET /version

查看版本信息

### GET /health

健康检查

---

## 💡 实际使用示例

### 示例 1: 本地批处理

```bash
#!/bin/bash
# 批量处理多个时间线

for timeline in timelines/*.json; do
  echo "Processing $timeline..."
  node demo-generate-command.js "$timeline" | bash
done
```

### 示例 2: Web 应用调用

```javascript
// 前端发送 timeline
const response = await fetch('https://your-worker.workers.dev/build', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(timeline)
});

const { command, args } = await response.json();

// 发送到后端执行
await executeFFmpeg(args);
```

### 示例 3: CI/CD 集成

```yaml
# GitHub Actions 示例
- name: Generate video
  run: |
    node demo-generate-command.js timeline.json > ffmpeg.sh
    bash ffmpeg.sh

- name: Upload video
  uses: actions/upload-artifact@v2
  with:
    name: output-video
    path: output.mp4
```

---

## 🎬 输入/输出对照

### 输入: simple-timeline.json

```json
{
  "version": 1,
  "inputs": {
    "source1": {
      "type": "video",
      "file": "samples/bee1920.mp4",
      "duration": 40
    },
    "source2": {
      "type": "video",
      "file": "samples/book1920.mp4",
      "duration": 13
    }
  },
  "tracks": {
    "track_with_some_videos": {
      "type": "video",
      "clips": [
        {
          "name": "clip4",
          "source": "source1",
          "timelineTrackStart": 0,
          "duration": 5,
          "sourceStartOffset": 27,
          "transform": {...}
        },
        {
          "name": "clip5",
          "source": "source2",
          "timelineTrackStart": 3,
          "duration": 5,
          "sourceStartOffset": 0,
          "transform": {...}
        }
      ]
    }
  },
  "transitions": [
    {
      "type": "fade",
      "duration": 2,
      "from": "clip4",
      "to": "clip5"
    }
  ],
  "output": {
    "file": "output.mp4",
    "width": 1920,
    "height": 1080,
    "framerate": 30
  }
}
```

### 输出: 可执行的 FFmpeg 命令

```bash
#!/bin/bash
mkdir -p ./tmp
ffmpeg -y -i samples/bee1920.mp4 -ss 27 -t 5 -r 30 ./tmp/clip4.mp4
ffmpeg -y -i samples/book1920.mp4 -ss 0 -t 5 -r 30 ./tmp/clip5.mp4
ffmpeg -y \
-i ./tmp/clip4.mp4 \
-i ./tmp/clip5.mp4 \
-filter_complex "color=c=black:s=384x216:d=8[base];
color=black@0.0:s=384x216:d=5[QGWFN9b4_base];
[0:v]scale=384:216,format=rgba,colorchannelmixer=aa=1[vqUV2OLd_clip];
[QGWFN9b4_base][vqUV2OLd_clip]overlay=0:0:format=auto,rotate=0,fps=30[clip4];
color=black@0.0:s=384x216:d=5[nxgbBHAZ_base];
[1:v]scale=80:60,format=rgba,colorchannelmixer=aa=1[Yxsqw6dl_clip];
[nxgbBHAZ_base][Yxsqw6dl_clip]overlay=10:10:format=auto,rotate=0,fps=30[clip5];
[clip4]fps=30[fps_clip4_1oC9mqUE];
[clip5]fps=30[fps_clip5_GJoOclwP];
[fps_clip4_1oC9mqUE][fps_clip5_GJoOclwP]xfade=transition=fade:duration=2:offset=3,fps=30[track_with_some_videos];
[base][track_with_some_videos]overlay=0:0[video_output];
anullsrc=channel_layout=stereo:sample_rate=44100:d=8[audio_output];" \
-map '[video_output]' -map '[audio_output]' -c:v libx264 -c:a aac -b:a 320k -r 30 -s 384x216 -ss 0 -t 8 -crf 23 -preset veryfast -pix_fmt yuv420p output.mp4
```

✅ **这个命令可以直接在终端执行!**

---

## 📁 相关文件

- **核心库入口**: [src/index.ts](../../src/index.ts) - `parseSchema()` 函数
- **Worker 入口**: [worker/src/index.ts](../../worker/src/index.ts) - API 路由
- **演示脚本**: [demo-generate-command.js](../../scripts/demo-generate-command.js) - 本地生成命令
- **完整测试**: [worker/test-api-complete.sh](../../worker/test-api-complete.sh) - Worker API 测试
- **测试文件**: [worker/test/fixtures/simple-timeline.json](../../worker/test/fixtures/simple-timeline.json)

---

## 🚀 部署到生产环境

```bash
# 配置 wrangler.toml
cd worker
vim wrangler.toml  # 添加账号信息

# 部署
npm run deploy

# 使用生产 URL
curl -X POST https://your-worker.workers.dev/build -d @timeline.json
```

---

## ✨ 总结

### 问题
> 是否可以做到 Cloudflare Worker 接口,输入 JSON timeline,输出可执行的 FFmpeg 命令字符串?

### 答案
✅ **完全可以,而且已经实现并测试通过!**

### 两种方式
1. **本地 Node.js**: 更简单直接
   ```bash
   node demo-generate-command.js input.json > output.sh
   ```

2. **Worker API**: 更灵活,适合 Web 应用
   ```bash
   curl -X POST http://localhost:8787/build -d @input.json | jq -r '.command'
   ```

### 核心特性
- ✅ 输入: JSON timeline
- ✅ 输出: 可直接执行的 FFmpeg 命令字符串
- ✅ 平台: Cloudflare Workers 兼容
- ✅ 格式: Shell 脚本字符串 + 参数数组
- ✅ 测试: 12 个测试全部通过

**立即尝试**: `bash worker/test-api-complete.sh` 🎉
