import { VideoEditorFormat } from "./types/VideoEditingFormat";
import { InputFiles } from "./types/InputFiles";
import { ImageMetadata } from "./types/Inputs";

/**
 * Return all the inputs as a part of ffmpeg command.
 * @param inputs
 */
export function parseInputs({ schema }: { schema: VideoEditorFormat }): {
  command: string;
  inputFiles: InputFiles;
} {
  let inputsCommand = "";
  const inputFiles: InputFiles = [];

  for (const [trackName, track] of Object.entries(schema.tracks)) {
    for (const clip of track.clips) {
      const { source, clipType, name, sourceStartOffset, duration } = clip;
      const { tempDir } = schema.output;

      // Only video clips need preprocessing and input files
      // Text clips are generated by drawtext filter
      if (clipType === "video") {
        inputsCommand += `-i ${tempDir}/${name}.mp4 \\\n`;
        inputFiles.push({
          file: `${name}_tmp.mp4`,
          name: `${name}`,
        });
      }
      // Skip text, audio, and image clips here - they're handled differently
    }
  }

  for (const [inputName, input] of Object.entries(schema.inputs)) {
    // Skip video inputs (handled in clips) and text inputs (generated by drawtext filter)
    if (input.type === "video" || input.type === "text") continue;

    // Handle GIF animations with special input options
    if (input.type === "image" && input.metadata) {
      const metadata = input.metadata as ImageMetadata;
      const isAnimated = metadata.imageType === "animated" || metadata.format === "gif";
      const shouldLoop = metadata.loop !== false; // Default to true

      if (isAnimated) {
        // For GIF animations, add loop control parameter
        if (shouldLoop) {
          // ignore_loop 0 means respect the loop count in GIF (infinite loop if set)
          inputsCommand += `-ignore_loop 0 -i ${input.file} \\\n`;
        } else {
          // ignore_loop 1 means play the GIF only once
          inputsCommand += `-ignore_loop 1 -i ${input.file} \\\n`;
        }
      } else {
        // Static image
        inputsCommand += `-i ${input.file} \\\n`;
      }
    } else {
      // Audio or image without metadata
      inputsCommand += `-i ${input.file} \\\n`;
    }

    inputFiles.push({
      name: inputName,
      file: input.file,
    });
  }

  return {
    command: inputsCommand,
    inputFiles,
  };
}
